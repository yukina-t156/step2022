# step2022
- Google STEP Development course2022で使用しました。
- 宿題の提出や自分の気づき、メモなどに使う予定です

***
## 自分用気づきメモ
### 第1回HW
- ファイル名はちゃんとrootから書いた方が移動しても使えるので良さそう  
  (例:"words.txt" -> "/Users/yukinatatsuta/step2022/lec01/words.txt")
- もっと関数で分けた方が何をしているかわかりやすいかな?
- スコア順の辞書を作ると早くなる！
  -> 思いついてはいたのでちゃんと作って比べてみればよかった!
- スコアの計算法の工夫
  -> 力技でなんとかなったものももっとスマートに解けないか考えてみる!
- ライブラリは使えるものは使う。何があるかもっと知りたい! ->調べる癖をつける。
- using namespace stdについて理解を深めたい。よくわからずずっと使っていた。
- マクロは避ける!
#### ※メンターさんのフィードバックがまだ読み切れていない! 読んでまとめる!  


### 第2回授業
- 計算量について スライドの辞書のソートのNMの部分がイマイチ(質問してたやつ アルファベット?)
- トライ木調べてみる  

### 第2回HW
- 問1
  - Nが2倍になった時に何倍になっているか調べればいい
  - グラフのスケールに注目するのを忘れてた!
- 問2 
  - 具体的に記述する!
  - 範囲検索は思いつかなかった。
- 問3
  - マークダウンで書いたけど使いこなせていない気がする。表とか図とかもうまく使用したい。
  - キャッシュの大きさXのn倍とするとハッシュテーブルの大きさはO(X)(定数倍)
  - LRU 情報処理の勉強で知っていたから自分で気づくことができた！うれしい。
- 発展クイズ
  - レインボーテーブルかな?
  - ソルト！知っているのが出るとなんか嬉しい.山月記みたいな感じ。
- 問4
  - ポインタの先のオブジェクトの寿命、スコープを意識する
  - vectorの領域の再確保した時にアドレスが変わることに注意
  - new / deleteについて調べる、使えるようにする

### 第3回授業
#### デバッグについて!
- 最初にやる：テストケース！
  - minimize
  - どこからエラーか？
  - 境界を見る
  - 小さいテストケースの方がデバッグも楽になる
- 問題の切り分け！
- assert
- にぶたん ちゃんと図を書くと条件などがわかりやすい  

#### モジュール化
- Pythonのインデントに慣れない。全然読めない。
- モジュール化された電卓 読んだメモ
  - 演算子とnumberが一対一対応している
  - numberが読み込まれた時のみ処理をするようになっている
  - tokenの中身:例えば1+3のとき、['+',1,'+',3]のような感じ
  - evaluate内がindex=1で始まるのは上のtoken[1]=1から始める(0番目は絶対+だから)
  - Python 返り値いっぱい持てるのすごい
  - indexは共有されてるから数字が来た時の1文字目でreadNumberに入れば数字を読み込める
- Chromeのコード 関数名めっちゃキャメルケースだ
- 全体から考える!いつも考えるより先に書いてしまうから意識する
- リーダブルコードちゃんと読み込もうと思った
- 無駄なコピペを無くす！！！
- 私もでっかいプログラム書いてみたい
- 美を意識しよう

### 第３回宿題
- 再帰関数きれいに書けそうでいいな
- スライドとかMDとかが上手な人多い、すごい
- 1個のテストで1個のことをテスト
  - 複雑なテストに丸投げしない!
- 関数ごとのテストも良い

### 第4回授業
- 再帰を止める
- while文でO(|V|)//全てのノードを必ず一回調べる必要がある
- for文でO(|E|) //全てのノードを必ず一回調べる

- O(|E|*|V|)にならないのは同じところは２度通らないから?
> DFSにせよBFSにせよ、何かしらの順序で、すべてのノードを一度ずつたどり（V）、すべてのエッジを一度ずつたどる（E）ので、O(V+E).もしE>Vであれば（たいていのグラフはそうです）、O(V+E) = O(E)になります。(はらけんさんより引用)
- 計算量は最悪の場合
> 辺を辿る(次のノードを見つける)処理をE回、頂点を判定する処理をV回するということですか？(てらもんさんより) -> そうです！ (はらけんさん)
> ノードが探している人かどうかで一度チェック(V) + 違った場合のノードから出ているエッジをチェック(E)という理解であってますか？(Seraさんより) -> そうです！（はらけんさん)


- ヒント:callstack

- コードレビュー：できるだけ往復のやりとりが少なくなるように

### 第４回宿題
- きれいなドキュメントかけるようになりたい！
- Callstuckについて
- 探索中ノードとのペアを持たせることでメモリを減らせる！
- Developerがユーザーの時や他の人が見るときは特にドキュメントをちゃんとする！
- 
### 第５回授業
- 何をしたいか言いながらの方がいい！
- わからないことは聞く！ライブラリとかは聞いても良い！
- 制約を聞けたり宣言できたら良い！(どんなものを作りたいかによるから)
  - 前提を確認する
  - 入出力例を書く
  - 方針を説明する 
- 聞くことを期待されている！
- 一緒に解く！
- ちゃんと質問できる人になる！
- エッジケースの見落としがないか確認する(入出力例が参考になると◎)


以下はらけんさんのコメントより
> P = Polynomial = 答えを多項式時間で見つけられる問題
> NP = Non deterministic Polynomial = 答えが与えられたときにそれが答えかどうかを多項式時間で確認できる問題
> NP = Non Polynomial ではないことに注意。

> NP Complete = NP完全 = NPの問題の中で最も難しい問題のこと

> NP Hard = NP困難
> NP完全 = NP困難かつNPな問題
> NP完全かNP困難かは、NPであるかどうかを問うかどうかの違い

>「すべての都市をひと筆書きする最短経路を求めよ」 => NPではない（答えが与えられたときにそれが最短経路かどうかを多項式時間では確認できない）のでNP困難
>「すべての都市をひと筆書きする経路で距離1000以下のものはあるか」 => NPなので（答えが与えられたとき距離1000以下かどうかを多項式時間で確認できる）のでNP完全



## officehour 6/7

- dense indexのときなど
  - なるべくvectorを使う
  - boolのvectorはあまり使わない

- 文字列
  - アルファベットか
- 数字
  - 小数か整数か
- リスト
  - 空リストの場合は?
  - 型は？
- コーナーケースは?
  - 例を作ってみる
  
- コードの正しさの吟味、主張、コードの説明
  - 例を使ってみる
  - ミスを見つけた時
    - 動かない例を自分で指摘できると良い
    - 面接官の方が指摘してくれるかも

- コードを書く時
  - 上から書く(mainなどの大きいところから、関数の内容は後で埋めてもいい)
  - 見た人がわかりやすいように
  - 実際の現場で書いてるような気持ちで

- 入出力は?
  - 入力は?
    - 関数の引数?標準入力?
  - 出力は?
    - printするか戻り値にするか?無効値はどうする?


- 計算量
  - forループ
  - 文字列をつなげた場合、文字列をハッシュテーブルに入れた時:長さの分の計算量がかかる
  

- 余談  
せっかくなのでGitHubに草を生やしたいな...と思い[こちら](https://findy-code.io/engineer-lab/github-contributions-rule)を実行。なんで草が生えないんだろうと思ってた。

## Officehour 6/14
※homework reviewも参照する！
- ヘッダファイルについて
  - 実装ファイル(.c,.cpp)とヘッダファイル(.h)に分かれている
- なぜヘッダがあるか?
  - コンパイルが遅いから！  
- 分割コンパイル  
  - ひとつの大きなファイルをコンパイルすると時間がかかる。
  いくつかの小さなファイルに分けると、最初のコンパイルのトータルの時間は変わらないが、変更があった時に少ない時間のコンパイルで済む。
  - 分割コンパイルの単位は実装ファイル
-  問題点は?
   -  他のファイルを参照しているとき！  
   -  関数  
        1.宣言 void f(int a);  
            ->ヘッダファイルに書く  
        2.実装 void f(int a){//実装}  
            ->実装ファイルに書く
- 変更した実装ファイル+ヘッダファイルでコンパイルする！
- どうやって変更したものを見つけるのか？
-> makeなど、そのための別のプログラムがある。更新日時などを参考に！

## Officehour 6/28


- 最適解よりx倍悪い解を保証する
  - https://manabitimes.jp/math/1130
- たくさん回さなくて済む

- たくさんやって改善する
- 貪欲法 -> Local minimum を避ける！
- 
- 焼きなまし法(シミュレーテッドアニーリング)
- 遺伝的探索法
- ビームサーチ

- たくさんループを回すことが大事！(確率的なものは特に) -> 高速化
- 貪欲法・シミュレーテッドアニーリング・ビームサーチ
  - どうやって隣の解を探すか
  - 見つけたものをどのように評価するか
    - TSPでは最終的には距離の長さ
    - 途中の評価は？
    - 
